<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>VOID BLOCKS - Neural Network Security Protocol</title>
  <style>
    :root {
      --bg: #000011;
      --panel: #001122;
      --terminal: #55ff55;
      --data: #55ffff;
      --virus: #ff5555;
      --warning: #ffaa55;
      --special: #ff55ff;
      --text: #cccccc;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      background: linear-gradient(180deg, var(--bg) 0%, #000022 100%);
      color: var(--text);
      overflow: hidden;
    }
    
    .container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      gap: 20px;
    }
    
    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    
    canvas {
      background: var(--panel);
      border: 2px solid var(--data);
      border-radius: 4px;
      box-shadow: 
        0 0 20px rgba(85, 255, 255, 0.3),
        inset 0 0 20px rgba(0, 17, 34, 0.8);
    }
    
    .panels {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .panel {
      background: rgba(0, 17, 34, 0.9);
      border: 1px solid var(--terminal);
      border-radius: 4px;
      padding: 15px;
      box-shadow: 0 0 10px rgba(85, 255, 85, 0.2);
    }
    
    .panel-title {
      color: var(--data);
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .title-panel .panel-title {
      color: var(--data);
      font-size: 16px;
      text-align: center;
      margin-bottom: 5px;
    }
    
    .subtitle {
      color: var(--terminal);
      font-size: 10px;
      text-align: center;
      opacity: 0.8;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 13px;
    }
    
    .stat-label {
      color: var(--text);
    }
    
    .stat-value {
      color: var(--terminal);
      font-weight: bold;
    }
    
    .score-value {
      color: var(--data);
      font-size: 18px;
      font-weight: bold;
    }
    
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    .status-stable { background: var(--terminal); }
    .status-unstable { background: var(--warning); }
    .status-critical { background: var(--virus); }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .controls {
      font-size: 11px;
      line-height: 1.4;
    }
    
    .control-row {
      margin: 4px 0;
      color: var(--text);
    }
    
    .key {
      color: var(--data);
      font-weight: bold;
    }
    
    .legend {
      margin-top: 10px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin: 4px 0;
      font-size: 11px;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      margin-right: 8px;
      border-radius: 2px;
    }
    
    .terminal { background: var(--terminal); }
    .data { background: var(--data); }
    .virus { background: var(--virus); }
    .warning { background: var(--warning); }
    .special { background: var(--special); }
    
    .game-over, .paused {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 17, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .overlay-text {
      color: var(--virus);
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px currentColor;
    }
    
    .overlay-subtitle {
      color: var(--data);
      font-size: 14px;
      margin-bottom: 20px;
    }
    
    .restart-hint {
      color: var(--terminal);
      font-size: 12px;
      animation: pulse 2s infinite;
    }
    
    .hidden {
      display: none;
    }
    
    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, var(--bg) 0%, #000022 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .start-content {
      max-width: 800px;
      max-height: 90vh;
      overflow-y: auto;
      background: rgba(0, 17, 34, 0.95);
      border: 2px solid var(--data);
      border-radius: 8px;
      padding: 30px;
      box-shadow: 0 0 30px rgba(85, 255, 255, 0.3);
    }
    
    .start-header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .start-title {
      color: var(--data);
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 10px;
      text-shadow: 0 0 10px currentColor;
      letter-spacing: 3px;
    }
    
    .start-subtitle {
      color: var(--terminal);
      font-size: 14px;
      opacity: 0.9;
    }
    
    .start-sections {
      display: grid;
      gap: 25px;
      margin-bottom: 30px;
    }
    
    .start-section {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--terminal);
      border-radius: 4px;
      padding: 20px;
    }
    
    .section-title {
      color: var(--warning);
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .section-content {
      color: var(--text);
      font-size: 13px;
      line-height: 1.5;
    }
    
    .fragment-item {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }
    
    .fragment-preview {
      width: 16px;
      height: 16px;
      margin-right: 12px;
      border-radius: 2px;
      box-shadow: 0 0 4px currentColor;
    }
    
    .fragment-desc {
      flex: 1;
    }
    
    .control-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    
    .control-item {
      display: flex;
      align-items: center;
    }
    
    .control-key {
      color: var(--data);
      font-weight: bold;
      min-width: 60px;
      margin-right: 10px;
    }
    
    .warning-item {
      margin: 8px 0;
      color: var(--text);
    }
    
    .start-footer {
      text-align: center;
    }
    
    .start-button {
      background: linear-gradient(45deg, var(--terminal), var(--data));
      border: 2px solid var(--data);
      border-radius: 6px;
      padding: 15px 30px;
      color: #000;
      font-family: inherit;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 15px rgba(85, 255, 255, 0.4);
    }
    
    .start-button:hover {
      background: linear-gradient(45deg, var(--data), var(--terminal));
      box-shadow: 0 0 25px rgba(85, 255, 255, 0.6);
      transform: translateY(-2px);
    }
    
    .start-button:active {
      transform: translateY(0);
      box-shadow: 0 0 10px rgba(85, 255, 255, 0.8);
    }
    
    .button-text {
      display: block;
      margin-bottom: 5px;
    }
    
    .button-hint {
      display: block;
      font-size: 10px;
      opacity: 0.8;
      font-weight: normal;
    }
    
    .version {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: rgba(204, 204, 204, 0.3);
      font-size: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="game-area">
      <canvas id="gameCanvas" width="300" height="600"></canvas>
      
      <div class="panels">
        <div class="panel title-panel">
          <div class="panel-title">VOID BLOCKS</div>
          <div class="subtitle">Neural Network Security Protocol v2.0</div>
        </div>
        
        <div class="panel">
          <div class="panel-title">System Status</div>
          <div class="stat-row">
            <span class="stat-label">SCORE</span>
            <span class="stat-value score-value" id="score">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">LEVEL</span>
            <span class="stat-value" id="level">1</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">LINES</span>
            <span class="stat-value" id="lines">0</span>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Network Status</div>
          <div class="stat-row">
            <span class="stat-label">CONNECTION</span>
            <span class="stat-value" id="connection">
              <span class="status-indicator status-stable"></span>STABLE
            </span>
          </div>
          <div class="stat-row">
            <span class="stat-label">INTEGRITY</span>
            <span class="stat-value" id="integrity">100%</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">CORRUPTION</span>
            <span class="stat-value" id="corruption">0%</span>
          </div>
        </div>
        
        <div class="panel">
          <div class="panel-title">Next Fragment</div>
          <canvas id="nextCanvas" width="120" height="80"></canvas>
        </div>
        
        <div class="panel">
          <div class="panel-title">Controls</div>
          <div class="controls">
            <div class="control-row"><span class="key">← / →</span> Move</div>
            <div class="control-row"><span class="key">↓</span> Soft Drop</div>
            <div class="control-row"><span class="key">SPACE</span> Hard Drop</div>
            <div class="control-row"><span class="key">↑ / Z / X</span> Rotate</div>
            <div class="control-row"><span class="key">P</span> Pause</div>
            <div class="control-row"><span class="key">R</span> Restart</div>
          </div>
          
          <div class="legend">
            <div class="panel-title" style="font-size: 12px; margin-bottom: 8px;">Block Types</div>
            <div class="legend-item">
              <div class="legend-color terminal"></div>
              <span>Standard Blocks</span>
            </div>
            <div class="legend-item">
              <div class="legend-color data"></div>
              <span>Data Fragments</span>
            </div>
            <div class="legend-item">
              <div class="legend-color virus"></div>
              <span>Virus Blocks</span>
            </div>
            <div class="legend-item">
              <div class="legend-color warning"></div>
              <span>Power-ups</span>
            </div>
            <div class="legend-item">
              <div class="legend-color special"></div>
              <span>Special Blocks</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="game-over hidden" id="gameOverScreen">
    <div class="overlay-text">SYSTEM COMPROMISED</div>
    <div class="overlay-subtitle">Neural network security breached</div>
    <div class="stat-row" style="color: var(--text); margin: 10px 0;">
      Final Score: <span style="color: var(--data);" id="finalScore">0</span>
    </div>
    <div class="restart-hint">Press R to restart security protocol</div>
  </div>
  
  <div class="paused hidden" id="pausedScreen">
    <div class="overlay-text">SYSTEM PAUSED</div>
    <div class="overlay-subtitle">Security protocol suspended</div>
    <div class="restart-hint">Press P to resume</div>
  </div>
  
  <div class="start-screen" id="startScreen">
    <div class="start-content">
      <div class="start-header">
        <div class="start-title">VOID BLOCKS</div>
        <div class="start-subtitle">Neural Network Security Protocol v2.0</div>
      </div>
      
      <div class="start-sections">
        <div class="start-section">
          <div class="section-title">📋 Mission Briefing</div>
          <div class="section-content">
            You are a security analyst tasked with preventing system corruption in a virtual reality network. Manipulate incoming data fragments to maintain system integrity and prevent virus propagation.
          </div>
        </div>
        
        <div class="start-section">
          <div class="section-title">🧬 Fragment Types</div>
          <div class="section-content">
            <div class="fragment-item">
              <div class="fragment-preview terminal"></div>
              <div class="fragment-desc"><strong>Standard Blocks</strong> - Basic green fragments (60%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview data"></div>
              <div class="fragment-desc"><strong>Data Fragments</strong> - Cyan blocks that slow time when cleared (20%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview virus"></div>
              <div class="fragment-desc"><strong>Virus Blocks</strong> - Red corruption that spreads to adjacent blocks (8%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview warning"></div>
              <div class="fragment-desc"><strong>Power-ups</strong> - Yellow blocks that clear all viruses (7%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview special"></div>
              <div class="fragment-desc"><strong>Special Blocks</strong> - Magenta fragments with bonus points (5%)</div>
            </div>
          </div>
        </div>
        
        <div class="start-section">
          <div class="section-title">🎮 Control Interface</div>
          <div class="section-content">
            <div class="control-grid">
              <div class="control-item"><span class="control-key">← →</span> Move fragments</div>
              <div class="control-item"><span class="control-key">↓</span> Soft drop</div>
              <div class="control-item"><span class="control-key">SPACE</span> Hard drop</div>
              <div class="control-item"><span class="control-key">↑/Z/X</span> Rotate fragments</div>
              <div class="control-item"><span class="control-key">P</span> Pause protocol</div>
              <div class="control-item"><span class="control-key">R</span> Restart system</div>
            </div>
          </div>
        </div>
        
        <div class="start-section">
          <div class="section-title">⚠️ System Warnings</div>
          <div class="section-content">
            <div class="warning-item">• Virus blocks spread to adjacent fragments every 3 seconds (30% chance)</div>
            <div class="warning-item">• System corruption increases with each virus block placed</div>
            <div class="warning-item">• Clear virus blocks to reduce corruption levels</div>
            <div class="warning-item">• Game over occurs when new fragments cannot be placed</div>
          </div>
        </div>
      </div>
      
      <div class="start-footer">
        <button class="start-button" id="startButton">
          <span class="button-text">INITIALIZE SECURITY PROTOCOL</span>
          <span class="button-hint">Press ENTER or click to begin</span>
        </button>
      </div>
    </div>
  </div>
  
  <div class="version">v2.0.0</div>

<script>
// VOID BLOCKS - Cyberpunk Tetris Implementation
(() => {
  const COLS = 10, ROWS = 20, BLOCK_SIZE = 30;
  const canvas = document.getElementById('gameCanvas');
  const nextCanvas = document.getElementById('nextCanvas');
  
  if (!canvas || !nextCanvas) {
    console.error('Canvas elements not found:', { canvas: !!canvas, nextCanvas: !!nextCanvas });
    return; // Exit early if critical elements missing
  }
  
  const ctx = canvas.getContext('2d');
  const nextCtx = nextCanvas.getContext('2d');
  
  if (!ctx || !nextCtx) {
    console.error('Canvas contexts not available:', { ctx: !!ctx, nextCtx: !!nextCtx });
    return; // Exit early if contexts unavailable
  }
  
  // Game colors matching cyberpunk theme
  const COLORS = {
    STANDARD: '#55ff55',    // Terminal green
    DATA: '#55ffff',        // Cyan
    VIRUS: '#ff5555',       // Red
    POWER: '#ffaa55',       // Yellow/Orange
    SPECIAL: '#ff55ff',     // Magenta
    BACKGROUND: '#001122'
  };
  
  // Tetris shapes
  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O: [[1,1],[1,1]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]]
  };
  
  const SHAPE_NAMES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
  
  // Block types with weights for random generation
  const BLOCK_TYPES = [
    { name: 'STANDARD', color: COLORS.STANDARD, weight: 60 },
    { name: 'DATA', color: COLORS.DATA, weight: 20 },
    { name: 'VIRUS', color: COLORS.VIRUS, weight: 8 },
    { name: 'POWER', color: COLORS.POWER, weight: 7 },
    { name: 'SPECIAL', color: COLORS.SPECIAL, weight: 5 }
  ];
  
  // Game state
  let board = createMatrix(ROWS, COLS);
  let virusBoard = createMatrix(ROWS, COLS); // Track virus infections
  let current = null;
  let next = null;
  let score = 0, level = 1, lines = 0;
  let dropTime = 0;
  let dropInterval = 1000;
  let lastTime = 0;
  let gameOver = false;
  let paused = false;
  let corruption = 0;
  let virusSpreadTimer = 0;
  let bag = [];
  let gameStarted = false;
  
  function createMatrix(rows, cols) {
    return Array.from({ length: rows }, () => Array(cols).fill(0));
  }
  
  function getRandomBlockType() {
    const totalWeight = BLOCK_TYPES.reduce((sum, type) => sum + type.weight, 0);
    const random = Math.random() * totalWeight;
    let accumulated = 0;
    
    for (let type of BLOCK_TYPES) {
      accumulated += type.weight;
      if (random <= accumulated) {
        return type;
      }
    }
    return BLOCK_TYPES[0];
  }
  
  function generateShapeBag() {
    const shuffled = [...SHAPE_NAMES];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  function createPiece() {
    if (bag.length === 0) {
      bag = generateShapeBag();
    }
    
    const shapeKey = bag.pop();
    const shape = SHAPES[shapeKey].map(row => [...row]);
    const blockType = getRandomBlockType();
    
    return {
      shape,
      x: Math.floor((COLS - shape[0].length) / 2),
      y: 0,
      type: blockType
    };
  }
  
  function rotate(matrix, clockwise = true) {
    const N = matrix.length;
    const rotated = Array.from({ length: N }, () => Array(N).fill(0));
    
    for (let i = 0; i < N; i++) {
      for (let j = 0; j < N; j++) {
        if (clockwise) {
          rotated[j][N - 1 - i] = matrix[i][j];
        } else {
          rotated[N - 1 - j][i] = matrix[i][j];
        }
      }
    }
    return rotated;
  }
  
  function isValidMove(piece, dx = 0, dy = 0, newShape = null) {
    const shape = newShape || piece.shape;
    const newX = piece.x + dx;
    const newY = piece.y + dy;
    
    for (let y = 0; y < shape.length; y++) {
      for (let x = 0; x < shape[y].length; x++) {
        if (shape[y][x]) {
          const boardX = newX + x;
          const boardY = newY + y;
          
          if (boardX < 0 || boardX >= COLS || 
              boardY >= ROWS || 
              (boardY >= 0 && board[boardY][boardX])) {
            return false;
          }
        }
      }
    }
    return true;
  }
  
  function placePiece(piece) {
    for (let y = 0; y < piece.shape.length; y++) {
      for (let x = 0; x < piece.shape[y].length; x++) {
        if (piece.shape[y][x]) {
          const boardX = piece.x + x;
          const boardY = piece.y + y;
          
          if (boardY >= 0) {
            board[boardY][boardX] = piece.type.color;
            
            // Mark virus blocks
            if (piece.type.name === 'VIRUS') {
              virusBoard[boardY][boardX] = 1;
              corruption = Math.min(100, corruption + 5);
            }
            
            // Random chance for standard blocks to become virus
            if (piece.type.name === 'STANDARD' && Math.random() < 0.1) {
              virusBoard[boardY][boardX] = 1;
              board[boardY][boardX] = COLORS.VIRUS;
            }
          }
        }
      }
    }
  }
  
  function clearLines() {
    let linesCleared = 0;
    let dataFragmentsCleared = 0;
    let virusBlocksCleared = 0;
    
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell !== 0)) {
        // Count special blocks in cleared line
        for (let x = 0; x < COLS; x++) {
          if (board[y][x] === COLORS.DATA) dataFragmentsCleared++;
          if (virusBoard[y][x]) virusBlocksCleared++;
        }
        
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        virusBoard.splice(y, 1);
        virusBoard.unshift(Array(COLS).fill(0));
        linesCleared++;
        y++; // Check the same line again
      }
    }
    
    if (linesCleared > 0) {
      // Scoring system
      const basePoints = [0, 40, 100, 300, 1200];
      let points = (basePoints[linesCleared] || 500) * level;
      
      // Bonus for data fragments
      if (dataFragmentsCleared > 0) {
        points *= (1 + dataFragmentsCleared * 0.5);
      }
      
      score += Math.floor(points);
      lines += linesCleared;
      
      // Reduce corruption when clearing virus blocks
      if (virusBlocksCleared > 0) {
        corruption = Math.max(0, corruption - virusBlocksCleared * 3);
      }
      
      // Level progression
      const newLevel = Math.floor(lines / 10) + 1;
      if (newLevel > level) {
        level = newLevel;
        dropInterval = Math.max(100, 1000 - (level - 1) * 50);
      }
      
      updateUI();
    }
  }
  
  function spreadVirus() {
    const newVirusBoard = virusBoard.map(row => [...row]);
    let spreadOccurred = false;
    
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (virusBoard[y][x]) {
          // Spread to adjacent cells
          const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          
          for (let [dx, dy] of directions) {
            const nx = x + dx;
            const ny = y + dy;
            
            if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS &&
                board[ny][nx] !== 0 && !virusBoard[ny][nx] && 
                Math.random() < 0.3) {
              
              newVirusBoard[ny][nx] = 1;
              board[ny][nx] = COLORS.VIRUS;
              corruption = Math.min(100, corruption + 2);
              spreadOccurred = true;
            }
          }
        }
      }
    }
    
    if (spreadOccurred) {
      virusBoard = newVirusBoard;
    }
  }
  
  function update(time = 0) {
    if (!gameStarted || gameOver || paused) return;
    
    const deltaTime = time - lastTime;
    lastTime = time;
    
    // Drop logic
    dropTime += deltaTime;
    if (dropTime > dropInterval) {
      if (current && isValidMove(current, 0, 1)) {
        current.y++;
      } else if (current) {
        placePiece(current);
        clearLines();
        spawnNext();
      }
      dropTime = 0;
    }
    
    // Virus spread logic
    virusSpreadTimer += deltaTime;
    if (virusSpreadTimer > 3000) { // Spread every 3 seconds
      spreadVirus();
      virusSpreadTimer = 0;
    }
    
    draw();
    updateUI();
    
    if (!gameOver) {
      requestAnimationFrame(update);
    }
  }
  
  function spawnNext() {
    current = next || createPiece();
    next = createPiece();
    
    if (!isValidMove(current)) {
      gameOver = true;
      showGameOver();
    }
  }
  
  function draw() {
    // Clear canvas
    ctx.fillStyle = COLORS.BACKGROUND;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw board grid
    ctx.strokeStyle = 'rgba(85, 255, 85, 0.1)';
    ctx.lineWidth = 1;
    
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK_SIZE, 0);
      ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
      ctx.stroke();
    }
    
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK_SIZE);
      ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Draw placed blocks
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x]) {
          drawBlock(x, y, board[y][x], virusBoard[y][x]);
        }
      }
    }
    
    // Draw current piece
    if (current) {
      for (let y = 0; y < current.shape.length; y++) {
        for (let x = 0; x < current.shape[y].length; x++) {
          if (current.shape[y][x]) {
            drawBlock(current.x + x, current.y + y, current.type.color);
          }
        }
      }
    }
    
    // Draw next piece
    drawNextPiece();
  }
  
  function drawBlock(x, y, color, isVirus = false) {
    const px = x * BLOCK_SIZE;
    const py = y * BLOCK_SIZE;
    
    ctx.fillStyle = color;
    ctx.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
    
    // Add glow effect
    ctx.shadowColor = color;
    ctx.shadowBlur = isVirus ? 8 : 4;
    ctx.fillRect(px + 3, py + 3, BLOCK_SIZE - 6, BLOCK_SIZE - 6);
    ctx.shadowBlur = 0;
    
    // Virus glitch effect
    if (isVirus && Math.random() < 0.3) {
      ctx.fillStyle = 'rgba(255, 85, 85, 0.8)';
      const offset = Math.random() * 4 - 2;
      ctx.fillRect(px + offset, py + offset, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
    }
  }
  
  function drawNextPiece() {
    nextCtx.fillStyle = COLORS.BACKGROUND;
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    if (next) {
      const blockSize = 15;
      const offsetX = (nextCanvas.width - next.shape[0].length * blockSize) / 2;
      const offsetY = (nextCanvas.height - next.shape.length * blockSize) / 2;
      
      for (let y = 0; y < next.shape.length; y++) {
        for (let x = 0; x < next.shape[y].length; x++) {
          if (next.shape[y][x]) {
            nextCtx.fillStyle = next.type.color;
            nextCtx.fillRect(
              offsetX + x * blockSize,
              offsetY + y * blockSize,
              blockSize - 1,
              blockSize - 1
            );
          }
        }
      }
    }
  }
  
  function updateUI() {
    // Update score with null check
    const scoreEl = document.getElementById('score');
    if (scoreEl) scoreEl.textContent = score.toLocaleString();
    
    const levelEl = document.getElementById('level');
    if (levelEl) levelEl.textContent = level;
    
    const linesEl = document.getElementById('lines');
    if (linesEl) linesEl.textContent = lines;
    
    // Update system status
    const integrity = Math.max(0, 100 - corruption);
    const integrityEl = document.getElementById('integrity');
    if (integrityEl) integrityEl.textContent = integrity + '%';
    
    const corruptionEl = document.getElementById('corruption');
    if (corruptionEl) corruptionEl.textContent = Math.floor(corruption) + '%';
    
    // Update connection status
    const connectionEl = document.getElementById('connection');
    if (connectionEl) {
      if (corruption < 30) {
        connectionEl.innerHTML = '<span class="status-indicator status-stable"></span>STABLE';
      } else if (corruption < 70) {
        connectionEl.innerHTML = '<span class="status-indicator status-unstable"></span>UNSTABLE';
      } else {
        connectionEl.innerHTML = '<span class="status-indicator status-critical"></span>CRITICAL';
      }
    }
  }
  
  function showGameOver() {
    const finalScoreEl = document.getElementById('finalScore');
    if (finalScoreEl) finalScoreEl.textContent = score.toLocaleString();
    
    const gameOverScreen = document.getElementById('gameOverScreen');
    if (gameOverScreen) {
      gameOverScreen.classList.remove('hidden');
    } else {
      console.error('Game over screen not found');
    }
  }
  
  function togglePause() {
    if (!gameStarted) return; // Don't allow pause before game starts
    
    paused = !paused;
    const pauseScreen = document.getElementById('pausedScreen');
    
    if (!pauseScreen) {
      console.error('Pause screen not found');
      paused = false; // Reset pause state if screen missing
      return;
    }
    
    if (paused) {
      pauseScreen.classList.remove('hidden');
    } else {
      pauseScreen.classList.add('hidden');
      lastTime = performance.now();
      requestAnimationFrame(update);
    }
  }
  
  function startGame() {
    if (gameStarted) {
      console.warn('Game already started, ignoring duplicate start request');
      return;
    }
    
    console.log('Starting game...');
    gameStarted = true;
    
    // Hide start screen with error handling
    const startScreen = document.getElementById('startScreen');
    if (startScreen) {
      startScreen.classList.add('hidden');
    } else {
      console.error('Start screen element not found');
    }
    
    // Initialize game state
    try {
      spawnNext();
      updateUI();
      lastTime = performance.now();
      requestAnimationFrame(update);
      console.log('Game started successfully');
    } catch (error) {
      console.error('Error starting game:', error);
      gameStarted = false; // Reset state on error
    }
  }
  
  function restart() {
    console.log('Restarting game...');
    
    // Reset game state
    board = createMatrix(ROWS, COLS);
    virusBoard = createMatrix(ROWS, COLS);
    current = null;
    next = null;
    score = 0;
    level = 1;
    lines = 0;
    corruption = 0;
    dropTime = 0;
    dropInterval = 1000;
    virusSpreadTimer = 0;
    gameOver = false;
    paused = false;
    bag = [];
    gameStarted = true;
    
    // Hide all overlay screens with error handling
    ['gameOverScreen', 'pausedScreen', 'startScreen'].forEach(screenId => {
      const screen = document.getElementById(screenId);
      if (screen) {
        screen.classList.add('hidden');
      } else {
        console.warn(`Screen element ${screenId} not found`);
      }
    });
    
    // Initialize game
    try {
      spawnNext();
      updateUI();
      lastTime = performance.now();
      requestAnimationFrame(update);
      console.log('Game restarted successfully');
    } catch (error) {
      console.error('Error restarting game:', error);
      gameStarted = false;
    }
  }
  
  // Initialize DOM event listeners when DOM is ready
  function initializeEventListeners() {
    // Start screen event listeners with error handling
    const startButton = document.getElementById('startButton');
    if (startButton) {
      startButton.addEventListener('click', startGame);
    } else {
      console.error('Start button not found in DOM');
    }
    
    // Input handling
    document.addEventListener('keydown', handleKeyInput);
  }
  
  function handleKeyInput(e) {
      // Start screen handling
      if (!gameStarted) {
        if (e.key === 'Enter') {
          startGame();
        }
        return;
      }
      
      if (gameOver) {
        if (e.key.toLowerCase() === 'r') {
          restart();
        }
        return;
      }
      
      if (paused && e.key.toLowerCase() !== 'p' && e.key.toLowerCase() !== 'r') {
        return;
      }
      
      switch (e.key) {
      case 'ArrowLeft':
        if (current && isValidMove(current, -1, 0)) {
          current.x--;
        }
        break;
        
      case 'ArrowRight':
        if (current && isValidMove(current, 1, 0)) {
          current.x++;
        }
        break;
        
      case 'ArrowDown':
        if (current && isValidMove(current, 0, 1)) {
          current.y++;
          dropTime = 0;
        }
        break;
        
      case ' ': // Hard drop
        if (current) {
          while (isValidMove(current, 0, 1)) {
            current.y++;
          }
          placePiece(current);
          clearLines();
          spawnNext();
          dropTime = 0;
        }
        e.preventDefault();
        break;
        
      case 'ArrowUp':
      case 'z':
      case 'Z':
        if (current) {
          const rotated = rotate(current.shape, false);
          if (isValidMove(current, 0, 0, rotated)) {
            current.shape = rotated;
          }
        }
        break;
        
      case 'x':
      case 'X':
        if (current) {
          const rotated = rotate(current.shape, true);
          if (isValidMove(current, 0, 0, rotated)) {
            current.shape = rotated;
          }
        }
        break;
        
      case 'p':
      case 'P':
        togglePause();
        break;
        
      case 'r':
      case 'R':
        restart();
        break;
    }
    
      if (e.key === 'ArrowDown' || e.key === ' ') {
        e.preventDefault();
      }
    }
  
  // Initialize game when DOM is fully loaded
  function initializeGame() {
    // Ensure start screen is visible
    const startScreen = document.getElementById('startScreen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
    }
    
    // Initialize event listeners
    initializeEventListeners();
    
    // Initialize UI
    updateUI();
    
    console.log('Game initialized successfully');
  }
  
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeGame);
  } else {
    initializeGame();
  }
})();
</script>
</body>
</html>